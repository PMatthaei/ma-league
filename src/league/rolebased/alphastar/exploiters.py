from typing import Tuple

from league.components.self_play import PFSPSampling
from league.rolebased.players import Player
import numpy as np


class MainExploiter(Player):

    def __init__(self, pid: int, payoff, team):
        super().__init__(pid, payoff, team)
        self._checkpoint_step = 0
        self._pfsp = PFSPSampling()

    def get_match(self) -> Tuple[Player, bool]:
        """

        :return:
        """
        from league.rolebased.alphastar.main_player import MainPlayer
        main_agents = [
            player for player in self.payoff.players
            if isinstance(player, MainPlayer)
        ]
        opponent = np.random.choice(main_agents)

        if self.payoff[self.tid, opponent.tid] > 0.1:
            return opponent, True

        from league.rolebased.players import HistoricalPlayer
        historical = [
            player.tid for player in self.payoff.players
            if isinstance(player, HistoricalPlayer) and player.parent == opponent
        ]
        win_rates = self.payoff[self.tid, historical]

        if len(historical) == 0:  # TODO
            return opponent, True

        chosen = self._pfsp.sample(historical, prio_measure=win_rates, weighting="variance")
        return self.payoff.players[chosen], True

    def checkpoint(self):
        """

        :return:
        """
        self._checkpoint_step = self.agent.trained_steps
        return self._create_checkpoint()

    def ready_to_checkpoint(self):
        """

        :return:
        """
        steps_passed = self.agent.trained_steps - self._checkpoint_step
        if steps_passed < 2e9:
            return False
        from league.rolebased.alphastar.main_player import MainPlayer
        main_agents = [
            player.tid for player in self.payoff.players
            if isinstance(player, MainPlayer)
        ]
        win_rates = self.payoff[self.tid, main_agents]
        return win_rates.min() > 0.7 or steps_passed > 4e9


class LeagueExploiter(Player):

    def __init__(self, pid: int, payoff, team):
        super().__init__(pid, payoff, team)
        self._checkpoint_step = 0
        self._pfsp = PFSPSampling()

    def get_match(self) -> Tuple[Player, bool]:
        """

        :return:
        """
        from league.rolebased.players import HistoricalPlayer

        historical = [
            player.tid for player in self.payoff.players
            if isinstance(player, HistoricalPlayer)
        ]
        win_rates = self.payoff[self.tid, historical]

        if len(historical) == 0:  # TODO
            return None, None

        chosen = self._pfsp.sample(historical, prio_measure=win_rates, weighting="linear_capped")
        return self.payoff.players[chosen], True

    def checkpoint(self):
        """

        :return:
        """
        # if np.random.random() < 0.25: TODO: reset at random to initial weights (when are they initial?)
        #     self.learner.set_weights(self._initial_weights)
        self._checkpoint_step = self.agent.trained_steps
        return self._create_checkpoint()

    def ready_to_checkpoint(self):
        """

        :return:
        """
        steps_passed = self.agent.trained_steps - self._checkpoint_step
        if steps_passed < 2e9:
            return False
        from league.rolebased.players import HistoricalPlayer
        historical = [
            player.tid for player in self.payoff.players
            if isinstance(player, HistoricalPlayer)
        ]
        win_rates = self.payoff[self.tid, historical]
        return win_rates.min() > 0.7 or steps_passed > 4e9
