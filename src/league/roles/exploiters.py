from typing import Tuple

from league.roles.agent import Agent
from league.roles.players import Player
import numpy as np

from league.components.pfsp import prioritized_fictitious_self_play


class MainExploiter(Player):

    def __init__(self, player_id, team_plan, agent, payoff):
        super().__init__()
        self.player_id = player_id
        self.agent = Agent(team_plan, agent.get_weights())
        self._initial_weights = agent.get_weights()
        self._payoff = payoff
        self._team_plan = agent.team_plan
        self._checkpoint_step = 0

    def get_match(self) -> Tuple[Player, bool]:
        """

        :return:
        """
        from league.roles.players import MainPlayer
        main_agents = [
            player for player in self._payoff.players
            if isinstance(player, MainPlayer)
        ]
        opponent = np.random.choice(main_agents)

        if self._payoff[self.player_id, opponent.player_id] > 0.1:
            return opponent, True

        from league.roles.players import HistoricalPlayer
        historical = [
            player.player_id for player in self._payoff.players
            if isinstance(player, HistoricalPlayer) and player.parent == opponent
        ]
        win_rates = self._payoff[self.player_id, historical]

        if len(historical) == 0: # TODO
            return opponent, True

        chosen_id = np.random.choice(historical, p=prioritized_fictitious_self_play(win_rates, weighting="variance"))
        return self._payoff.players[chosen_id], True

    def checkpoint(self):
        """

        :return:
        """
        self.agent.set_weights(self._initial_weights)
        self._checkpoint_step = self.agent.get_steps()
        return self._create_checkpoint()

    def ready_to_checkpoint(self):
        """

        :return:
        """
        steps_passed = self.agent.get_steps() - self._checkpoint_step
        if steps_passed < 2e9:
            return False
        from league.roles.players import MainPlayer
        main_agents = [
            player.player_id for player in self._payoff.players
            if isinstance(player, MainPlayer)
        ]
        win_rates = self._payoff[self.player_id, main_agents]
        return win_rates.min() > 0.7 or steps_passed > 4e9


class LeagueExploiter(Player):

    def __init__(self, player_id, team_plan, agent, payoff):
        super().__init__()
        self.player_id = player_id
        self.agent = Agent(team_plan, agent.get_weights())
        self._initial_weights = agent.get_weights()
        self._payoff = payoff
        self._team_plan = agent.team_plan
        self._checkpoint_step = 0

    def get_match(self) -> Tuple[Player, bool]:
        """

        :return:
        """
        from league.roles.players import HistoricalPlayer

        historical = [
            player.player_id for player in self._payoff.players
            if isinstance(player, HistoricalPlayer)
        ]
        win_rates = self._payoff[self.player_id, historical]
        chosen_id = np.random.choice(historical, p=prioritized_fictitious_self_play(win_rates, weighting="linear_capped"))
        return self._payoff.players[chosen_id], True

    def checkpoint(self):
        """

        :return:
        """
        if np.random.random() < 0.25:
            self.agent.set_weights(self._initial_weights)
        self._checkpoint_step = self.agent.get_steps()
        return self._create_checkpoint()

    def ready_to_checkpoint(self):
        """

        :return:
        """
        steps_passed = self.agent.get_steps() - self._checkpoint_step
        if steps_passed < 2e9:
            return False
        from league.roles.players import HistoricalPlayer
        historical = [
            player.player_id for player in self._payoff.players
            if isinstance(player, HistoricalPlayer)
        ]
        win_rates = self._payoff[self.player_id, historical]
        return win_rates.min() > 0.7 or steps_passed > 4e9
